import { 
  collection, 
  addDoc, 
  query, 
  where, 
  orderBy, 
  onSnapshot,
  updateDoc,
  doc,
  getDocs,
  writeBatch,
  serverTimestamp,
  Timestamp,
  getDoc
} from "firebase/firestore";
import { db } from "./firebase";
import { getFriends } from "./friendService";
import { getUserPushToken, sendPushNotification } from "./pushNotificationService";

/**
 * Notification types
 */
export const NOTIFICATION_TYPES = {
  NEW_PHOTO: "new_photo",
  FRIEND_REQUEST: "friend_request",
  FRIEND_ACCEPTED: "friend_accepted",
  FAMILY_INVITATION: "family_invitation",
  FAMILY_ACCEPTED: "family_accepted",
  FAMILY_DECLINED: "family_declined",
};

/**
 * Send notification to a single user
 */
export async function sendNotification(recipientId, notification) {
  try {
    const notificationData = {
      recipientId,
      senderId: notification.senderId,
      senderName: notification.senderName,
      senderAvatar: notification.senderAvatar || null,
      type: notification.type,
      title: notification.title,
      message: notification.message,
      data: notification.data || {},
      read: false,
      createdAt: serverTimestamp(),
    };

    const docRef = await addDoc(collection(db, "notifications"), notificationData);
    console.log("‚úÖ Notification sent:", docRef.id);
    
    // Send push notification
    try {
      const pushToken = await getUserPushToken(recipientId);
      if (pushToken) {
        await sendPushNotification(
          pushToken,
          notification.title,
          notification.message,
          notification.data
        );
        console.log("‚úÖ Push notification sent to:", recipientId);
      }
    } catch (pushError) {
      console.warn("‚ö†Ô∏è Failed to send push notification:", pushError);
      // Don't throw - Firestore notification was created successfully
    }
    
    return docRef.id;
  } catch (error) {
    console.error("‚ùå Error sending notification:", error);
    throw error;
  }
}

/**
 * Send notification to multiple users (batch)
 */
export async function sendNotificationToMultiple(recipientIds, notification) {
  try {
    const batch = writeBatch(db);
    const notificationsRef = collection(db, "notifications");
    
    const promises = recipientIds.map(recipientId => {
      const notificationData = {
        recipientId,
        senderId: notification.senderId,
        senderName: notification.senderName,
        senderAvatar: notification.senderAvatar || null,
        type: notification.type,
        title: notification.title,
        message: notification.message,
        data: notification.data || {},
        read: false,
        createdAt: serverTimestamp(),
      };
      
      return addDoc(notificationsRef, notificationData);
    });

    await Promise.all(promises);
    console.log(`‚úÖ Sent ${recipientIds.length} notifications`);
    return true;
  } catch (error) {
    console.error("‚ùå Error sending batch notifications:", error);
    throw error;
  }
}

/**
 * Notify all friends about a new photo
 */
export async function notifyFriendsAboutNewPhoto(userId, userName, photoData) {
  try {
    console.log("üì¢ Notifying friends about new photo...");
    
    // Get user's friends
    const friends = await getFriends(userId);
    
    if (friends.length === 0) {
      console.log("‚ÑπÔ∏è No friends to notify");
      return;
    }

    const friendIds = friends.map(f => f.uid);
    
    // Create notification
    const notification = {
      senderId: userId,
      senderName: userName,
      senderAvatar: null,
      type: NOTIFICATION_TYPES.NEW_PHOTO,
      title: "·∫¢nh m·ªõi",
      message: `${userName} ƒë√£ ƒëƒÉng ·∫£nh m·ªõi`,
      data: {
        photoId: photoData.id,
        photoUrl: photoData.cloudinaryUrl || photoData.uri,
        caption: photoData.caption || photoData.note || "",
      }
    };

    await sendNotificationToMultiple(friendIds, notification);
    console.log(`‚úÖ Notified ${friendIds.length} friends`);
  } catch (error) {
    console.error("‚ùå Error notifying friends:", error);
    throw error;
  }
}

/**
 * Subscribe to user's notifications (real-time)
 */
export function subscribeToNotifications(userId, callback) {
  try {
    const q = query(
      collection(db, "notifications"),
      where("recipientId", "==", userId),
      orderBy("createdAt", "desc")
    );

    const unsubscribe = onSnapshot(
      q,
      (snapshot) => {
        const notifications = [];
        snapshot.forEach((doc) => {
          const data = doc.data();
          notifications.push({
            id: doc.id,
            ...data,
            createdAt: data.createdAt?.toDate?.() || new Date(),
          });
        });
        
        console.log(`üì¨ Received ${notifications.length} notifications`);
        callback(notifications);
      },
      (error) => {
        console.error("‚ùå Error in notification listener:", error);
        callback([]);
      }
    );

    return unsubscribe;
  } catch (error) {
    console.error("‚ùå Error subscribing to notifications:", error);
    throw error;
  }
}

/**
 * Mark notification as read
 */
export async function markNotificationAsRead(notificationId) {
  try {
    const notificationRef = doc(db, "notifications", notificationId);
    await updateDoc(notificationRef, {
      read: true,
      readAt: serverTimestamp(),
    });
    console.log("‚úÖ Notification marked as read:", notificationId);
  } catch (error) {
    console.error("‚ùå Error marking notification as read:", error);
    throw error;
  }
}

/**
 * Mark all notifications as read
 */
export async function markAllNotificationsAsRead(userId) {
  try {
    const q = query(
      collection(db, "notifications"),
      where("recipientId", "==", userId),
      where("read", "==", false)
    );

    const snapshot = await getDocs(q);
    const batch = writeBatch(db);

    snapshot.forEach((document) => {
      batch.update(document.ref, {
        read: true,
        readAt: serverTimestamp(),
      });
    });

    await batch.commit();
    console.log(`‚úÖ Marked ${snapshot.size} notifications as read`);
  } catch (error) {
    console.error("‚ùå Error marking all notifications as read:", error);
    throw error;
  }
}

/**
 * Get unread notification count
 */
export async function getUnreadNotificationCount(userId) {
  try {
    const q = query(
      collection(db, "notifications"),
      where("recipientId", "==", userId),
      where("read", "==", false)
    );

    const snapshot = await getDocs(q);
    return snapshot.size;
  } catch (error) {
    console.error("‚ùå Error getting unread count:", error);
    return 0;
  }
}

/**
 * Delete notification
 */
export async function deleteNotification(notificationId) {
  try {
    await deleteDoc(doc(db, "notifications", notificationId));
    console.log("‚úÖ Notification deleted:", notificationId);
  } catch (error) {
    console.error("‚ùå Error deleting notification:", error);
    throw error;
  }
}

/**
 * Send family invitation notification
 */
export async function sendFamilyInvitationNotification(recipientId, senderName, familyName, familyId) {
  try {
    const notification = {
      senderId: recipientId, // Placeholder, will be overridden
      senderName: senderName,
      senderAvatar: null,
      type: NOTIFICATION_TYPES.FAMILY_INVITATION,
      title: "L·ªùi m·ªùi gia ƒë√¨nh",
      message: `${senderName} ƒë√£ m·ªùi b·∫°n v√†o gia ƒë√¨nh "${familyName}"`,
      data: {
        familyId: familyId,
        familyName: familyName,
      }
    };

    await sendNotification(recipientId, notification);
    console.log("‚úÖ Family invitation notification sent");
  } catch (error) {
    console.error("‚ùå Error sending family invitation notification:", error);
    throw error;
  }
}

/**
 * Send family accepted notification
 */
export async function sendFamilyAcceptedNotification(recipientId, accepterName, familyName) {
  try {
    const notification = {
      senderId: recipientId, // Placeholder
      senderName: accepterName,
      senderAvatar: null,
      type: NOTIFICATION_TYPES.FAMILY_ACCEPTED,
      title: "L·ªùi m·ªùi ƒë∆∞·ª£c ch·∫•p nh·∫≠n",
      message: `${accepterName} ƒë√£ ch·∫•p nh·∫≠n l·ªùi m·ªùi v√†o gia ƒë√¨nh "${familyName}"`,
      data: {
        familyName: familyName,
      }
    };

    await sendNotification(recipientId, notification);
    console.log("‚úÖ Family accepted notification sent");
  } catch (error) {
    console.error("‚ùå Error sending family accepted notification:", error);
    throw error;
  }
}

/**
 * Send family declined notification
 */
export async function sendFamilyDeclinedNotification(recipientId, declinerName, familyName) {
  try {
    const notification = {
      senderId: recipientId, // Placeholder
      senderName: declinerName,
      senderAvatar: null,
      type: NOTIFICATION_TYPES.FAMILY_DECLINED,
      title: "L·ªùi m·ªùi b·ªã t·ª´ ch·ªëi",
      message: `${declinerName} ƒë√£ t·ª´ ch·ªëi l·ªùi m·ªùi v√†o gia ƒë√¨nh "${familyName}"`,
      data: {
        familyName: familyName,
      }
    };

    await sendNotification(recipientId, notification);
    console.log("‚úÖ Family declined notification sent");
  } catch (error) {
    console.error("‚ùå Error sending family declined notification:", error);
    throw error;
  }
}
